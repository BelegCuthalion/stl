\section{Notation} In the following, $\mathcal{S}$ and $\mathcal{T}$ are names for sequences of finite multi-sets, of which at most finitely many are non-empty; $\mathcal{R}$ for a finite sequence, possibly of length $0$; $\#(\mathcal{R})$ for its length; $\epsilon_n$ for the sequence of empty multi-sets, of length $n$; $\epsilon$ for the sequence of empty multi-sets, $\Gamma$, $\Sigma$ and $\Delta$ for finite multi-sets, $A$, $B$ and $C$ for formulas and $n$, $l$, $r$ and $k$ for natural numbers. We will write $A$ for the singleton $\{A\}$ and $\Gamma$ for the finite sequence $\langle\Gamma\rangle$ of length $1$.
``$,$'' is the multi-set union.
``$\cup$'' is the point-wise union of sequences.
``$|$'' is a right-associative binary operator, overloaded and used for two functions: concatenation of finite sequences, making a finite sequence out of two; and concatenation of an infinite sequence on the left, to a finite sequence on the right, making an infinite sequence. Notice that $\epsilon_0$ is the right-identity element for both functions. Also notice that for any $\mathcal{S}$, since only finitely many multi-sets in $\mathcal{S}$ are non-empty, we can write $\mathcal{S}$ as $\epsilon | \mathcal{R}$ for some finite sequence $\mathcal{R}$.

\section{GSTL$^-$} ‌\\
\begin{multicols}{3}
	\begin{prooftree}
		\RightLabel{$Ax$}
		\AXC{}
		\UIC{$\epsilon|A \Rightarrow A$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$Ta$}
		\AXC{}
		\UIC{$\epsilon \Rightarrow \top$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$Ex$}
		\AXC{}
		\UIC{$\epsilon |‌\bot | \epsilon_n \Rightarrow$}
	\end{prooftree}
\end{multicols}
‌\\
\begin{multicols}{3}
	\begin{prooftree}
		\RightLabel{$Lw$}
		\AXC{$\mathcal{S} | \Gamma | \mathcal{R} \Rightarrow \Delta$}
		\UIC{$\mathcal{S} | \Gamma , A | \mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$Rw$}
		\AXC{$\mathcal{S} \Rightarrow$}
		\UIC{$\mathcal{S} \Rightarrow A$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$Lc$}
		\AXC{$\mathcal{S} |‌\Gamma , A , A |‌\mathcal{R} \Rightarrow \Delta$}
		\UIC{$\mathcal{S} | \Gamma , A | \mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
\end{multicols}
‌\\
\begin{multicols}{3}
	\begin{prooftree}
		\RightLabel{$L\land_1$}
		\AXC{$\mathcal{S} |‌\Gamma , A | \mathcal{R} \Rightarrow \Delta$}
		\UIC{$\mathcal{S} |‌\Gamma , A \land B |‌\mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$L\land_2$}
		\AXC{$\mathcal{S} |‌\Gamma , B | \mathcal{R} \Rightarrow \Delta$}
		\UIC{$\mathcal{S} |‌\Gamma , A \land B | \mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$R\land$}
		\AXC{$\mathcal{S} \Rightarrow A$}
		\AXC{$\mathcal{S} \Rightarrow B$}
		\BIC{$\mathcal{S} \Rightarrow A \land B$}
	\end{prooftree}
\end{multicols}
‌\\
\begin{multicols}{3}
	\begin{prooftree}
		\RightLabel{$L\lor$}
		\AXC{$\mathcal{S} |‌\Gamma , A |‌\mathcal{R} \Rightarrow \Delta$}
		\AXC{$\mathcal{S} |‌\Gamma , B | \mathcal{R} \Rightarrow \Delta$}
		\BIC{$\mathcal{S} |‌\Gamma , A \lor B | \mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$R\lor_1$}
		\AXC{$\mathcal{S} \Rightarrow A$}
		\UIC{$\mathcal{S} \Rightarrow A \lor B$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$R\lor_2$}
		\AXC{$\mathcal{S} \Rightarrow B$}
		\UIC{$\mathcal{S} \Rightarrow A \lor B$}
	\end{prooftree}
\end{multicols}
‌\\
\begin{multicols}{2}
	\begin{prooftree}
		\RightLabel{$L\rightarrow$}
		\AXC{$\mathcal{S} | \Gamma | \Sigma | \mathcal{R} \Rightarrow \nabla^{l(\mathcal{R})} A$}
		\AXC{$\mathcal{S} | \Gamma | \Sigma , B | \mathcal{R} \Rightarrow \Delta$}
		\BIC{$\mathcal{S} | \Gamma, A \rightarrow B | \Sigma | \mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
	\columnbreak
	\begin{prooftree}
		\RightLabel{$R\rightarrow$}
		\AXC{$\mathcal{S} | A \Rightarrow B$}
		\UIC{$\mathcal{S} \Rightarrow A \rightarrow B$}
	\end{prooftree}
\end{multicols}
‌\\
\begin{multicols}{2}
	\begin{prooftree}
		\RightLabel{$L\nabla$}
		\AXC{$\mathcal{S} |‌\Gamma , A | \Sigma |‌\mathcal{R} \Rightarrow \Delta$}
		\UIC{$\mathcal{S} |‌\Gamma | \Sigma , \nabla A |‌\mathcal{R} \Rightarrow \Delta$}
	\end{prooftree}
	
	\begin{prooftree}
		\RightLabel{$R\nabla$}
		\AXC{$\mathcal{S} \Rightarrow \Delta$}
		\UIC{$\mathcal{S} | \epsilon_1 \Rightarrow \nabla \Delta$}
	\end{prooftree}
\end{multicols}
‌\\
\subsection{$Cut$}
\begin{prooftree}
	\RightLabel{$Cut$}
	\AXC{$\mathcal{S} \Rightarrow A$}
	\AXC{$\mathcal{T} | \Gamma, A | \mathcal{R} \Rightarrow \Delta$}
	\BIC{$[ \mathcal{S} | \epsilon_{\#(\mathcal{R})} ] \cup [ \mathcal{T} | \Gamma | \mathcal{R} ] \Rightarrow \Delta$}
\end{prooftree}

\subsection{$\nabla Cut$} For any $l,k \ge 0$ and $n \ge 1$
\begin{prooftree}
	\AXC{$\mathcal{S} \Rightarrow \nabla^k A$}
	\AXC{$\mathcal{T} \cup [A^n | \epsilon_{k+l}] \Rightarrow \Delta$}
	\RightLabel{$\nabla Cut$}
	\BIC{$[ \mathcal{S} | \epsilon_l ] \cup \mathcal{T} \Rightarrow \Delta$}
\end{prooftree}
$A$ is called the \textit{cut-formula}.

\subsubsection{Rank} For a formula $\varphi$,
\[ \rho(\varphi) = \begin{cases}
1 & \quad ; \varphi \in P \cup \{ \bot, \top \} \\
\rho(\psi) + 1 & \quad ; \varphi = \nabla \psi \\
max(\rho(\psi), \rho(\theta)) + 1 & \quad ; \varphi = \psi \Box \theta, \Box \in \{ \land , \lor, \rightarrow \}
\end{cases} \]
For an instance of the $\nabla Cut$ rule $c$ with cut-formula $\varphi$, $\rho(c) = \rho(\varphi)$, $0$ if it's not an instance of the $\nabla Cut$ rule.
For a proof tree $\mathbf{D}$, $\rho(\mathbf{D})$ is the maximum rank of its $\nabla Cut$ rules, $0$ if $\mathbf{D}$ is cut-free.

\subsection{Theorem} For any $\Gamma$ and $\Delta$, if $\small\text{GSTL}^- + Cut \vdash \Gamma \Rightarrow \Delta$ then $\small\text{GSTL}^- + \nabla Cut \vdash \Gamma \Rightarrow \Delta$.

\textit{Proof}: Just replace any occurrence if $Cut$ with $\nabla Cut$, with $k := 0$ and $n := 1$.
